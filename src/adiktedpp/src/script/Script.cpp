/*
 * Script.cpp
 *
 */

#include "adiktedpp/script/Script.h"

#include "adiktedpp/Messages.h"
#include "adiktedpp/Version.h"

#include "utils/Log.h"

extern "C" {
    #include "libadikted/lev_files.h"
    #include "libadikted/lev_script.h"
    #include "libadikted/lev_data.h"
}


using namespace adiktedpp;


namespace adiktedpp {
    namespace script {

        std::string scriptName( const PlayerType item ) {
            switch( item ) {
            case PlayerType::PT_0:      return "PLAYER0";
            case PlayerType::PT_1:      return "PLAYER1";
            case PlayerType::PT_2:      return "PLAYER2";
            case PlayerType::PT_3:      return "PLAYER3";
            case PlayerType::PT_GOOD:   return "PLAYER_GOOD";
            case PlayerType::PT_UNSET:  return "PLAYER_UNSET";          /// unavailable in script
            case PlayerType::PT_ALL:    return "ALL_PLAYERS";
            }
            return "UNKNOWN_PLAYER";
        }

        std::string scriptName( const raw::SubTypeCreature item ) {
            switch( item ) {
            case raw::SubTypeCreature::STC_WIZRD:    return "WIZARD";
            case raw::SubTypeCreature::STC_BARBARIN: return "BARBARIAN";
            case raw::SubTypeCreature::STC_ARCHER:   return "ARCHER";
            case raw::SubTypeCreature::STC_MONK:     return "MONK";
            case raw::SubTypeCreature::STC_DWAFT:    return "DWARFA";
            case raw::SubTypeCreature::STC_KNIGHT:   return "KNIGHT";
            case raw::SubTypeCreature::STC_AVATAR:   return "AVATAR";
            case raw::SubTypeCreature::STC_TUNELER:  return "TUNNELLER";
            case raw::SubTypeCreature::STC_WITCH:    return "WITCH";
            case raw::SubTypeCreature::STC_GIANT:    return "GIANT";
            case raw::SubTypeCreature::STC_FAIRY:    return "FAIRY";
            case raw::SubTypeCreature::STC_THEFT:    return "THIEF";
            case raw::SubTypeCreature::STC_SMURI:    return "SAMURAI";

            case raw::SubTypeCreature::STC_HORNY:    return "HORNY";
            case raw::SubTypeCreature::STC_SKELETON: return "SKELETON";
            case raw::SubTypeCreature::STC_TROLL:    return "TROLL";
            case raw::SubTypeCreature::STC_DRAGON:   return "DRAGON";
            case raw::SubTypeCreature::STC_SPAWN:    return "DEMONSPAWN";
            case raw::SubTypeCreature::STC_FLY:      return "FLY";
            case raw::SubTypeCreature::STC_MISTRESS: return "DARK_MISTRESS";
            case raw::SubTypeCreature::STC_WARLOCK:  return "SORCEROR";
            case raw::SubTypeCreature::STC_BILEDEMN: return "BILE_DEMON";
            case raw::SubTypeCreature::STC_IMP:      return "IMP";
            case raw::SubTypeCreature::STC_BEETLE:   return "BUG";
            case raw::SubTypeCreature::STC_VAMPIRE:  return "VAMPIRE";
            case raw::SubTypeCreature::STC_SPIDER:   return "SPIDER";
            case raw::SubTypeCreature::STC_HOUND:    return "HELL_HOUND";
            case raw::SubTypeCreature::STC_GHOST:    return "GHOST";
            case raw::SubTypeCreature::STC_TENTCL:   return "TENTACLE";
            case raw::SubTypeCreature::STC_ORC:      return "ORC";
            case raw::SubTypeCreature::STC_FLOAT:    return "FLOATING_SPIRIT";
            }
            return "UNKNOWN_CREATURE";
        }


        /// =========================================================================


        Script::Script( Level& level ): levelPtr(&level) {
            addLine( "REM *** script generated by dkmage -- DK map generator v. " + VERSION_FULL_STRING + " ***" );
            addLine( "" );
        }

        void Script::rebuild() {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return ;
            }

            convertToTextArray();
            decompose_script( &(level->script), &(level->optns.script) );
            script_decomposed_to_params( &(level->script), &(level->optns.script) );

    //        recompose();
        }

        /// convert DK_SCRIPT::list to text lines
        bool Script::recompose() {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return false;
            }
            struct DK_SCRIPT *scrpt = get_lvl_script( level );
            recompute_script_levels( scrpt );
            const bool retcode = recompose_script( scrpt, &(level->optns.script) );
            if (retcode)
                LOG() << "Script recomposed successfully";
            else
                LOG() << "Error occured during the update";
            return retcode;
        }

        void Script::execScriptADI( const std::string& path ) {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return ;
            }
            char msg[ LINEMSG_SIZE ];
            char* msgPtr = &msg[0];
            memset( msgPtr, 0, sizeof(msg) );
            char* fname = (char*) path.c_str();
            script_load_and_execute_file( level, fname, msgPtr );
            LOG() << "message: " << msg;
        }

        bool Script::executeLine( const std::string& line ) {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return false;
            }
            const char* linePtr = line.c_str();
            char msg[ LINEMSG_SIZE ];
            char* msgPtr = &msg[0];
            memset( msgPtr, 0, sizeof(msg) );
            const bool valid = execute_script_line( level, (char*)linePtr, msgPtr );
            if ( valid == false ) {
                LOG() << "message: " << msg;
            }
            return valid;
        }

        bool Script::addAvailable( const PlayerType player, const Room item, const int accessible, const int available ) {
            std::stringstream stream;
            stream << AvailableCommand::SAC_ROOM_AVAILABLE << "( " << scriptName( player ) << ", " << item << ", " << accessible << ", " << available << " )";
            const std::string& line = stream.str();
            return addLine( line );
        }

        bool Script::addAvailable( const PlayerType player, const Creature item, const int accessible, const int available ) {
            std::stringstream stream;
            stream << AvailableCommand::SAC_CREATURE_AVAILABLE << "( " << scriptName( player ) << ", " << item << ", " << accessible << ", " << available << " )";
            const std::string& line = stream.str();
            return addLine( line );
        }

        bool Script::addAvailable( const PlayerType player, const Door item, const int accessible, const int available ) {
            std::stringstream stream;
            stream << AvailableCommand::SAC_DOOR_AVAILABLE << "( " << scriptName( player ) << ", " << item << ", " << accessible << ", " << available << " )";
            const std::string& line = stream.str();
            return addLine( line );
        }

        bool Script::addAvailable( const PlayerType player, const Trap item, const int accessible, const int available ) {
            std::stringstream stream;
            stream << AvailableCommand::SAC_TRAP_AVAILABLE << "( " << scriptName( player ) << ", " << item << ", " << accessible << ", " << available << " )";
            const std::string& line = stream.str();
            return addLine( line );
        }

        bool Script::addAvailable( const PlayerType player, const Spell item, const int accessible, const int available ) {
            std::stringstream stream;
            stream << AvailableCommand::SAC_MAGIC_AVAILABLE << "( " << scriptName( player ) << ", " << item << ", " << accessible << ", " << available << " )";
            const std::string& line = stream.str();
            return addLine( line );
        }

        bool Script::addLine( const std::string& line ) {
            lines.push_back( line );
            return true;
        }

        bool Script::addLine( const std::string& line, const std::size_t position ) {
            if ( position >= lines.size() ) {
                lines.push_back( line );
                return true;
            }
            auto pos = lines.begin();
            std::advance( pos, position );
            lines.insert( pos, line );
            return true;
        }

        void Script::setEvilCreaturesPool( const std::size_t number ) {
            std::set< raw::SubTypeCreature > list = raw::SubTypeCreatureEvil();
            list.erase( raw::SubTypeCreature::STC_HORNY );
            list.erase( raw::SubTypeCreature::STC_FLOAT );
            list.erase( raw::SubTypeCreature::STC_IMP );
            list.erase( raw::SubTypeCreature::STC_TENTCL );
            list.erase( raw::SubTypeCreature::STC_VAMPIRE );
            list.erase( raw::SubTypeCreature::STC_SKELETON );
            for ( const raw::SubTypeCreature item: list ) {
                setCreaturePool( item, number );
            }
        }

        void Script::setHeroCreaturesPool( const std::size_t number ) {
            std::set< raw::SubTypeCreature > list = raw::SubTypeCreatureHero();
            list.erase( raw::SubTypeCreature::STC_AVATAR );
            for ( const raw::SubTypeCreature item: list ) {
                setCreaturePool( item, number );
            }
        }

        void Script::setCreaturePool( const raw::SubTypeCreature creature, const std::size_t number ) {
            std::stringstream stream;
            stream << "ADD_CREATURE_TO_POOL( " << scriptName( creature ) << ", " << number << " )";
            const std::string& line = stream.str();
            addLine( line );
        }

        void Script::setEvilCreaturesAvailable( const PlayerType player, const bool available ) {
            CreatureAvailableState availableState;
            availableState.setEvilAvailable( player, available );
            set( availableState );
        }

        void Script::setHeroCreaturesAvailable( const PlayerType player, const bool available ) {
            CreatureAvailableState availableState;
            availableState.setHeroAvailable( player, available );
            set( availableState );
        }

        void Script::setRoomsAvailable( const PlayerType player, const AvailableMode mode ) {
            RoomsAvailableState availableState;
            availableState.setAllAvailable( player, mode );
            set( availableState );
        }

        void Script::setRoomAvailable( const PlayerType player, const Room room, const AvailableMode mode ) {
            RoomsAvailableState availableState;
            availableState.setStateMode( player, room, mode );
            set( availableState );
        }

        void Script::setRoomsStandard() {
            RoomsAvailableState availableState;
            availableState.setStandard();
            set( availableState );
        }

        void Script::setDoorsAvailable( const PlayerType player, const int available ) {
            DoorAvailableState availableState;
            availableState.setAllAvailable( player, available );
            set( availableState );
        }

        void Script::setTrapsAvailable( const PlayerType player, const int available ) {
            TrapAvailableState availableState;
            availableState.setAllAvailable( player, available );
            set( availableState );
        }

        void Script::setMagicAvailable( const PlayerType player, const AvailableMode mode ) {
            MagicAvailableState availableState;
            availableState.setAllAvailable( player, mode );
            set( availableState );
        }

        void Script::setMagicStandard( const PlayerType player ) {
            MagicAvailableState availableState;
            availableState.setStandard( player );
            set( availableState );
        }

        void Script::setWinConditionStandard( const PlayerType player ) {
            std::stringstream stream;
            addLine( std::string() + "IF( " + scriptName( player ) + ", ALL_DUNGEONS_DESTROYED == 1 )" );
            addLine( std::string() + "    WIN_GAME" );
            addLine( std::string() + "ENDIF" );
        }

        void Script::convertToTextArray() {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return ;
            }

            freeTxt();

            const std::size_t lines_count = lines.size();
            level->script.txt  = (char **) malloc( lines_count * sizeof(unsigned char *) );
            level->script.list = (struct DK_SCRIPT_COMMAND **) malloc( lines_count * sizeof(struct DK_SCRIPT_COMMAND *) );
            for (std::size_t currline=0; currline<lines_count; ++currline) {
                level->script.list[currline] = NULL;      /* decompose_script() will allocate memory for it */

                const std::string& dataLine = lines[ currline ];
                const std::size_t dataSize = dataLine.size();
                level->script.txt[currline] = (char *) malloc( (dataSize+1) * sizeof(char) );
                memcpy( level->script.txt[currline], dataLine.c_str(), dataSize );
                level->script.txt[currline][ dataSize ] = '\0';
            }
            level->script.lines_count = lines_count;
        }

        void Script::freeTxt() {
            LEVEL* level = levelPtr->rawData();
            if ( level == nullptr ) {
                LOG() << "uninitialized level";
                return ;
            }

            int idx = level->script.lines_count;
            while (idx > 0) {
              idx--;
              free( level->script.txt[idx] );
              free( level->script.list[idx] );
            }
            free( level->script.txt );
            free( level->script.list );
            level->script.lines_count = 0;
        }

    }
} /* namespace adiktedpp */
