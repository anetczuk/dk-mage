/*
 * Script.cpp
 *
 */

#include "adiktedpp/Script.h"

#include "adiktedpp/Messages.h"

#include "utils/Log.h"

extern "C" {
    #include "libadikted/lev_files.h"
    #include "libadikted/lev_script.h"
    #include "libadikted/lev_data.h"
}


namespace adiktedpp {

    Script::Script( Level& level ): levelPtr(&level) {
        addLine( "REM *** script generated by dkmage -- DK map generator v. 1.0.1 ***" );
        addLine( "" );
    }

    void Script::rebuild() {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return ;
        }

        convertToTextArray();
        decompose_script( &(level->script), &(level->optns.script) );
        script_decomposed_to_params( &(level->script), &(level->optns.script) );

//        recompose();
    }

    /// convert DK_SCRIPT::list to text lines
    bool Script::recompose() {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return false;
        }
        struct DK_SCRIPT *scrpt = get_lvl_script( level );
        recompute_script_levels( scrpt );
        const bool retcode = recompose_script( scrpt, &(level->optns.script) );
        if (retcode)
            LOG() << "Script recomposed successfully";
        else
            LOG() << "Error occured during the update";
        return retcode;
    }

    void Script::execScriptADI( const std::string& path ) {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return ;
        }
        char msg[ LINEMSG_SIZE ];
        char* msgPtr = &msg[0];
        memset( msgPtr, 0, sizeof(msg) );
        char* fname = (char*) path.c_str();
        script_load_and_execute_file( level, fname, msgPtr );
        LOG() << "message: " << msg;
    }

    bool Script::executeLine( const std::string& line ) {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return false;
        }
        const char* linePtr = line.c_str();
        char msg[ LINEMSG_SIZE ];
        char* msgPtr = &msg[0];
        memset( msgPtr, 0, sizeof(msg) );
        const bool valid = execute_script_line( level, (char*)linePtr, msgPtr );
        if ( valid == false ) {
            LOG() << "message: " << msg;
        }
        return valid;
    }

    bool Script::addLine( const std::string& line ) {
        lines.push_back( line );
        return true;
    }

    bool Script::addLine( const std::string& line, const std::size_t position ) {
        if ( position >= lines.size() ) {
            lines.push_back( line );
            return true;
        }
        auto pos = lines.begin();
        std::advance( pos, position );
        lines.insert( pos, line );
        return true;
    }

    void Script::convertToTextArray() {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return ;
        }

        freeTxt();

        const std::size_t lines_count = lines.size();
        level->script.txt  = (char **) malloc( lines_count * sizeof(unsigned char *) );
        level->script.list = (struct DK_SCRIPT_COMMAND **) malloc( lines_count * sizeof(struct DK_SCRIPT_COMMAND *) );
        for (std::size_t currline=0; currline<lines_count; ++currline) {
            level->script.list[currline] = NULL;      /* decompose_script() will allocate memory for it */

            const std::string& dataLine = lines[ currline ];
            const std::size_t dataSize = dataLine.size();
            level->script.txt[currline] = (char *) malloc( (dataSize+1) * sizeof(char) );
            memcpy( level->script.txt[currline], dataLine.c_str(), dataSize );
            level->script.txt[currline][ dataSize ] = '\0';
        }
        level->script.lines_count = lines_count;
    }

    void Script::freeTxt() {
        LEVEL* level = levelPtr->rawData();
        if ( level == nullptr ) {
            LOG() << "uninitialized level";
            return ;
        }

        int idx = level->script.lines_count;
        while (idx > 0) {
          idx--;
          free( level->script.txt[idx] );
          free( level->script.list[idx] );
        }
        free( level->script.txt );
        free( level->script.list );
        level->script.lines_count = 0;
    }

} /* namespace adiktedpp */
